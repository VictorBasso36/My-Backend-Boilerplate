# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Auth {
  """JWT access token"""
  accessToken: JWT!

  """JWT refresh token"""
  refreshToken: JWT!
  user: User!
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input ChangePasswordInput {
  newPassword: String!
  oldPassword: String!
}

type Comment {
  CommentResponse: [CommentResponse!]
  Company: Company!
  _count: CommentCount!
  approved: Boolean!
  companyId: String!
  content: String!
  createdAt: DateTime!
  id: ID!
  rating: Float
  updatedAt: DateTime!
}

type CommentCount {
  CommentResponse: Int!
}

input CommentCreateManyCompanyInput {
  approved: Boolean
  content: String!
  createdAt: DateTime
  id: String
  rating: Float
  updatedAt: DateTime
}

input CommentCreateManyCompanyInputEnvelope {
  data: [CommentCreateManyCompanyInput!]!
  skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutCompanyInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutCompanyInput!]
  create: [CommentCreateWithoutCompanyInput!]
  createMany: CommentCreateManyCompanyInputEnvelope
}

input CommentCreateOrConnectWithoutCompanyInput {
  create: CommentCreateWithoutCompanyInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutCompanyInput {
  CommentResponse: CommentResponseCreateNestedManyWithoutCommentInput
  approved: Boolean
  content: String!
  createdAt: DateTime
  id: String
  rating: Float
  updatedAt: DateTime
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentRelationFilter {
  is: CommentWhereInput
  isNot: CommentWhereInput
}

type CommentResponse {
  Comment: Comment!
  CommentId: String!
  content: String!
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
}

input CommentResponseCreateManyCommentInput {
  content: String!
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input CommentResponseCreateManyCommentInputEnvelope {
  data: [CommentResponseCreateManyCommentInput!]!
  skipDuplicates: Boolean
}

input CommentResponseCreateNestedManyWithoutCommentInput {
  connect: [CommentResponseWhereUniqueInput!]
  connectOrCreate: [CommentResponseCreateOrConnectWithoutCommentInput!]
  create: [CommentResponseCreateWithoutCommentInput!]
  createMany: CommentResponseCreateManyCommentInputEnvelope
}

input CommentResponseCreateOrConnectWithoutCommentInput {
  create: CommentResponseCreateWithoutCommentInput!
  where: CommentResponseWhereUniqueInput!
}

input CommentResponseCreateWithoutCommentInput {
  content: String!
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input CommentResponseListRelationFilter {
  every: CommentResponseWhereInput
  none: CommentResponseWhereInput
  some: CommentResponseWhereInput
}

input CommentResponseWhereInput {
  AND: [CommentResponseWhereInput!]
  Comment: CommentRelationFilter
  CommentId: StringFilter
  NOT: [CommentResponseWhereInput!]
  OR: [CommentResponseWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  updatedAt: DateTimeFilter
}

input CommentResponseWhereUniqueInput {
  AND: [CommentResponseWhereInput!]
  Comment: CommentRelationFilter
  CommentId: StringFilter
  NOT: [CommentResponseWhereInput!]
  OR: [CommentResponseWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: String
  updatedAt: DateTimeFilter
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  CommentResponse: CommentResponseListRelationFilter
  Company: CompanyRelationFilter
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  approved: BoolFilter
  companyId: StringFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  rating: FloatNullableFilter
  updatedAt: DateTimeFilter
}

input CommentWhereUniqueInput {
  AND: [CommentWhereInput!]
  CommentResponse: CommentResponseListRelationFilter
  Company: CompanyRelationFilter
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  approved: BoolFilter
  companyId: StringFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: String
  rating: FloatNullableFilter
  updatedAt: DateTimeFilter
}

type Company {
  Comment: [Comment!]
  User: [User!]
  _count: CompanyCount!
  cnpj: String!
  createdAt: DateTime!
  id: ID!
  location: String!
  name: String!
  rating: Float
  ratingCount: Int
  updatedAt: DateTime!
}

type CompanyCount {
  Comment: Int!
  User: Int!
}

input CompanyCreateInput {
  Comment: CommentCreateNestedManyWithoutCompanyInput
  User: UserCreateNestedManyWithoutCompanyInput
  cnpj: String!
  createdAt: DateTime
  id: String
  location: String!
  name: String!
  rating: Float
  ratingCount: Int
  updatedAt: DateTime
}

input CompanyNullableRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

enum CompanyOrderByRelevanceFieldEnum {
  cnpj
  id
  location
  name
}

input CompanyOrderByRelevanceInput {
  fields: [CompanyOrderByRelevanceFieldEnum!]!
  search: String!
  sort: SortOrder!
}

input CompanyOrderByWithRelationAndSearchRelevanceInput {
  Comment: CommentOrderByRelationAggregateInput
  User: UserOrderByRelationAggregateInput
  _relevance: CompanyOrderByRelevanceInput
  cnpj: SortOrder
  createdAt: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  rating: SortOrderInput
  ratingCount: SortOrderInput
  updatedAt: SortOrder
}

input CompanyRelationFilter {
  is: CompanyWhereInput
  isNot: CompanyWhereInput
}

enum CompanyScalarFieldEnum {
  cnpj
  createdAt
  id
  location
  name
  rating
  ratingCount
  updatedAt
}

input CompanyWhereInput {
  AND: [CompanyWhereInput!]
  Comment: CommentListRelationFilter
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  User: UserListRelationFilter
  cnpj: StringFilter
  createdAt: DateTimeFilter
  id: StringFilter
  location: StringFilter
  name: StringFilter
  rating: FloatNullableFilter
  ratingCount: IntNullableFilter
  updatedAt: DateTimeFilter
}

input CompanyWhereUniqueInput {
  AND: [CompanyWhereInput!]
  Comment: CommentListRelationFilter
  NOT: [CompanyWhereInput!]
  OR: [CompanyWhereInput!]
  User: UserListRelationFilter
  cnpj: String
  createdAt: DateTimeFilter
  id: String
  location: StringFilter
  name: StringFilter
  rating: FloatNullableFilter
  ratingCount: IntNullableFilter
  updatedAt: DateTimeFilter
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

"""
A field whose value is a JSON Web Token (JWT): https://jwt.io/introduction.
"""
scalar JWT

input LoginInput {
  email: String!
  password: String!
}

type Mutation {
  changePassword(data: ChangePasswordInput!): User!
  createCompany(data: CompanyCreateInput!): Company!
  login(data: LoginInput!): Auth!
  refreshToken(token: JWT!): Token!
  signup(data: SignupInput!): Auth!
  updateUser(data: UpdateUserInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type Query {
  companys(cursor: CompanyWhereUniqueInput, distinct: [CompanyScalarFieldEnum!], orderBy: [CompanyOrderByWithRelationAndSearchRelevanceInput!], skip: Int, take: Int, where: CompanyWhereInput): [Company!]
  findUniqueCompany(where: CompanyWhereUniqueInput!): Company
  hello(name: String!): String!
  helloWorld: String!
  me: User!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

input SignupInput {
  email: String!
  firstname: String
  lastname: String
  password: String!
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  search: String
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  search: String
  startsWith: String
}

type Token {
  """JWT access token"""
  accessToken: JWT!

  """JWT refresh token"""
  refreshToken: JWT!
}

input UpdateUserInput {
  firstname: String
  lastname: String
}

type User {
  Company: Company
  companyId: String
  createdAt: DateTime!
  email: String!
  firstname: String
  id: ID!
  lastname: String
  password: String!
  resetPasswordExpires: DateTime
  resetPasswordToken: String
  role: Role!
  updatedAt: DateTime!
}

input UserCreateManyCompanyInput {
  createdAt: DateTime
  email: String!
  firstname: String
  id: String
  lastname: String
  password: String!
  resetPasswordExpires: DateTime
  resetPasswordToken: String
  role: Role!
  updatedAt: DateTime
}

input UserCreateManyCompanyInputEnvelope {
  data: [UserCreateManyCompanyInput!]!
  skipDuplicates: Boolean
}

input UserCreateNestedManyWithoutCompanyInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutCompanyInput!]
  create: [UserCreateWithoutCompanyInput!]
  createMany: UserCreateManyCompanyInputEnvelope
}

input UserCreateOrConnectWithoutCompanyInput {
  create: UserCreateWithoutCompanyInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutCompanyInput {
  createdAt: DateTime
  email: String!
  firstname: String
  id: String
  lastname: String
  password: String!
  resetPasswordExpires: DateTime
  resetPasswordToken: String
  role: Role!
  updatedAt: DateTime
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserWhereInput {
  AND: [UserWhereInput!]
  Company: CompanyNullableRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  companyId: StringNullableFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstname: StringNullableFilter
  id: StringFilter
  lastname: StringNullableFilter
  password: StringFilter
  resetPasswordExpires: DateTimeNullableFilter
  resetPasswordToken: StringNullableFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  Company: CompanyNullableRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  companyId: StringNullableFilter
  createdAt: DateTimeFilter
  email: String
  firstname: StringNullableFilter
  id: String
  lastname: StringNullableFilter
  password: StringFilter
  resetPasswordExpires: DateTimeNullableFilter
  resetPasswordToken: String
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}