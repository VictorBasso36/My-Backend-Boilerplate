"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
const graphql_fields_1 = __importDefault(require("graphql-fields"));
const jest_mock_1 = require("jest-mock");
const src_1 = require("../src");
const fixtures_1 = require("./fixtures");
function encodeCursor(prismaCursor) {
    return Buffer.from(JSON.stringify(prismaCursor)).toString('base64');
}
function decodeCursor(cursor) {
    return JSON.parse(Buffer.from(cursor, 'base64').toString('ascii'));
}
jest.mock('graphql-fields');
const mockGraphqlFields = (0, jest_mock_1.mocked)(graphql_fields_1.default);
describe('prisma-relay-cursor-connection', () => {
    jest.setTimeout(10000);
    let client;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        client = new client_1.PrismaClient();
    }));
    afterAll(() => __awaiter(void 0, void 0, void 0, function* () {
        yield client.$disconnect();
    }));
    describe('string id', () => {
        beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
            yield client.todo.deleteMany({});
            for (let i = 0; i !== fixtures_1.TODO_FIXTURES.length; i++) {
                yield client.todo.create({ data: fixtures_1.TODO_FIXTURES[i] });
            }
        }));
        it('returns all todos with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.todo.findMany({});
            expect(result).toEqual(fixtures_1.TODO_FIXTURES);
        }));
        it('returns the paginated todos with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.todo.findMany({ cursor: { id: 'id_05' }, take: 5, skip: 1 });
            expect(result).toMatchSnapshot();
        }));
        const VALID_CASES = [
            ['returns all todos', undefined],
            ['returns the first 5 todos', { first: 5 }],
            ['returns the first 5 todos after the 1st todo', { first: 5, after: 'id_01' }],
            ['returns the first 5 todos after the 5th todo', { first: 5, after: 'id_05' }],
            ['returns the first 5 todos after the 15th todo', { first: 5, after: 'id_15' }],
            ['returns the first 5 todos after the 16th todo', { first: 5, after: 'id_16' }],
            ['returns the first 5 todos after the 20th todo', { first: 5, after: 'id_20' }],
            ['returns the last 5 todos', { last: 5 }],
            ['returns the last 5 todos before the 1st todo', { last: 5, before: 'id_01' }],
            ['returns the last 5 todos before the 5th todo', { last: 5, before: 'id_05' }],
            ['returns the last 5 todos before the 6th todo', { last: 5, before: 'id_06' }],
            ['returns the last 5 todos before the 16th todo', { last: 5, before: 'id_16' }],
        ];
        test.each(VALID_CASES)('%s', (name, connectionArgs) => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, src_1.findManyCursorConnection)((args) => client.todo.findMany(args), () => client.todo.count(), connectionArgs);
            expect(result).toMatchSnapshot();
        }));
        it('returns the first 5 completed todos', () => __awaiter(void 0, void 0, void 0, function* () {
            const baseArgs = {
                select: { id: true, isCompleted: true },
                where: { isCompleted: true },
            };
            const result = yield (0, src_1.findManyCursorConnection)((args) => client.todo.findMany(Object.assign(Object.assign({}, args), baseArgs)), () => client.todo.count({ where: baseArgs.where }), { first: 5 });
            expect(result).toMatchSnapshot();
            result.edges[0].node.isCompleted;
            result.edges[0].node.isCompletedd;
            result.edges[0].node.text;
            result.nodes[0].isCompleted;
            result.nodes[0].isCompletedd;
            result.nodes[0].text;
        }));
    });
    describe('number id', () => {
        beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
            yield client.user.deleteMany({});
            for (let i = 0; i !== fixtures_1.USER_FIXTURES.length; i++) {
                yield client.user.create({ data: fixtures_1.USER_FIXTURES[i] });
            }
        }));
        it('returns all users with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.user.findMany({});
            expect(result).toEqual(fixtures_1.USER_FIXTURES);
        }));
        it('returns the paginated users with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.user.findMany({ cursor: { id: 5 }, take: 5, skip: 1 });
            expect(result).toMatchSnapshot();
        }));
        const NUMBER_ID_VALID_CASES = [
            ['returns all users', undefined],
            ['returns the first 5 users', { first: 5 }],
            [
                'returns the first 5 users after the 1st user',
                { first: 5, after: encodeCursor({ id: 1 }) },
            ],
            [
                'returns the first 5 users after the 5th user',
                { first: 5, after: encodeCursor({ id: 5 }) },
            ],
            [
                'returns the first 5 users after the 15th user',
                { first: 5, after: encodeCursor({ id: 15 }) },
            ],
            [
                'returns the first 5 users after the 16th user',
                { first: 5, after: encodeCursor({ id: 16 }) },
            ],
            [
                'returns the first 5 users after the 20th user',
                { first: 5, after: encodeCursor({ id: 20 }) },
            ],
            ['returns the last 5 users', { last: 5 }],
            [
                'returns the last 5 users before the 1st user',
                { last: 5, before: encodeCursor({ id: 1 }) },
            ],
            [
                'returns the last 5 users before the 5th user',
                { last: 5, before: encodeCursor({ id: 5 }) },
            ],
            [
                'returns the last 5 users before the 6th user',
                { last: 5, before: encodeCursor({ id: 6 }) },
            ],
            [
                'returns the last 5 users before the 16th user',
                { last: 5, before: encodeCursor({ id: 16 }) },
            ],
        ];
        test.each(NUMBER_ID_VALID_CASES)('%s', (name, connectionArgs) => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, src_1.findManyCursorConnection)((args) => client.user.findMany(args), () => client.user.count(), connectionArgs, {
                getCursor: (record) => ({ id: record.id }),
                decodeCursor,
                encodeCursor,
            });
            expect(result).toMatchSnapshot();
        }));
    });
    describe('unique field', () => {
        beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
            yield client.user.deleteMany({});
            for (let i = 0; i !== fixtures_1.USER_FIXTURES.length; i++) {
                yield client.user.create({ data: fixtures_1.USER_FIXTURES[i] });
            }
        }));
        it('returns all users with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.user.findMany({});
            expect(result).toEqual(fixtures_1.USER_FIXTURES);
        }));
        it('returns the paginated users with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.user.findMany({
                cursor: { email: 'user5@email.com' },
                take: 5,
                skip: 1,
            });
            expect(result).toMatchSnapshot();
        }));
        const UNIQUE_FIELD_VALID_CASES = [
            [
                'returns the first 5 users after the 1st user',
                { first: 5, after: encodeCursor({ email: 'user1@email.com' }) },
            ],
            [
                'returns the first 5 users after the 5th user',
                { first: 5, after: encodeCursor({ email: 'user5@email.com' }) },
            ],
            [
                'returns the first 5 users after the 15th user',
                { first: 5, after: encodeCursor({ email: 'user15@email.com' }) },
            ],
            [
                'returns the first 5 users after the 16th user',
                { first: 5, after: encodeCursor({ email: 'user16@email.com' }) },
            ],
            [
                'returns the first 5 users after the 20th user',
                { first: 5, after: encodeCursor({ email: 'user20@email.com' }) },
            ],
            [
                'returns the last 5 users before the 1st user',
                { last: 5, before: encodeCursor({ email: 'user1@email.com' }) },
            ],
            [
                'returns the last 5 users before the 5th user',
                { last: 5, before: encodeCursor({ email: 'user5@email.com' }) },
            ],
            [
                'returns the last 5 users before the 6th user',
                { last: 5, before: encodeCursor({ email: 'user6@email.com' }) },
            ],
            [
                'returns the last 5 users before the 16th user',
                { last: 5, before: encodeCursor({ email: 'user16@email.com' }) },
            ],
        ];
        test.each(UNIQUE_FIELD_VALID_CASES)('%s', (name, connectionArgs) => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, src_1.findManyCursorConnection)((args) => client.user.findMany(args), () => client.user.count(), connectionArgs, {
                getCursor: (record) => ({ email: record.email }),
                decodeCursor,
                encodeCursor,
            });
            expect(result).toMatchSnapshot();
        }));
    });
    describe('multi field id', () => {
        beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
            yield client.profile.deleteMany({});
            for (let i = 0; i !== fixtures_1.PROFILE_FIXTURES.length; i++) {
                yield client.profile.create({ data: fixtures_1.PROFILE_FIXTURES[i] });
            }
        }));
        it('returns all profiles with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.profile.findMany({});
            expect(result).toEqual(fixtures_1.PROFILE_FIXTURES);
        }));
        it('returns the paginated profiles with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.profile.findMany({
                cursor: { firstname_lastname: { firstname: 'foo5', lastname: 'bar1' } },
                take: 5,
                skip: 1,
            });
            expect(result).toMatchSnapshot();
        }));
        const MULTI_FIELD_ID_VALID_CASES = [
            ['returns the first 5 profiles', { first: 5 }],
            [
                'returns the first 5 profiles after the 1st profile',
                {
                    first: 5,
                    after: encodeCursor({ firstname_lastname: { firstname: 'foo1', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the first 5 profiles after the 5th profile',
                {
                    first: 5,
                    after: encodeCursor({ firstname_lastname: { firstname: 'foo5', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the first 5 profiles after the 15th profile',
                {
                    first: 5,
                    after: encodeCursor({ firstname_lastname: { firstname: 'foo15', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the first 5 profiles after the 16th profile',
                {
                    first: 5,
                    after: encodeCursor({ firstname_lastname: { firstname: 'foo16', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the first 5 profiles after the 20th profile',
                {
                    first: 5,
                    after: encodeCursor({ firstname_lastname: { firstname: 'foo20', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the last 5 profiles before the 1st profile',
                {
                    last: 5,
                    before: encodeCursor({ firstname_lastname: { firstname: 'foo1', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the last 5 profiles before the 5th profile',
                {
                    last: 5,
                    before: encodeCursor({ firstname_lastname: { firstname: 'foo5', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the last 5 profiles before the 6th profile',
                {
                    last: 5,
                    before: encodeCursor({ firstname_lastname: { firstname: 'foo6', lastname: 'bar1' } }),
                },
            ],
            [
                'returns the last 5 profiles before the 16th profile',
                {
                    last: 5,
                    before: encodeCursor({ firstname_lastname: { firstname: 'foo16', lastname: 'bar1' } }),
                },
            ],
        ];
        test.each(MULTI_FIELD_ID_VALID_CASES)('%s', (name, connectionArgs) => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, src_1.findManyCursorConnection)((args) => client.profile.findMany(args), () => client.profile.count(), connectionArgs, {
                getCursor: (record) => ({
                    firstname_lastname: {
                        firstname: record.firstname,
                        lastname: record.lastname,
                    },
                }),
                decodeCursor,
                encodeCursor,
            });
            expect(result).toMatchSnapshot();
        }));
    });
    describe('custom edge fields', () => {
        beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
            yield client.todo.deleteMany({});
            for (let i = 0; i !== fixtures_1.TODO_FIXTURES.length; i++) {
                yield client.todo.create({ data: fixtures_1.TODO_FIXTURES[i] });
            }
        }));
        it('returns all todos with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.todo.findMany({});
            expect(result).toEqual(fixtures_1.TODO_FIXTURES);
        }));
        it('returns the paginated todos with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.todo.findMany({ cursor: { id: 'id_05' }, take: 5, skip: 1 });
            expect(result).toMatchSnapshot();
        }));
        const VALID_CASES = [
            ['returns all todos', undefined],
            ['returns the first 5 todos', { first: 5 }],
            ['returns the first 5 todos after the 1st todo', { first: 5, after: 'id_01' }],
            ['returns the first 5 todos after the 5th todo', { first: 5, after: 'id_05' }],
            ['returns the first 5 todos after the 15th todo', { first: 5, after: 'id_15' }],
            ['returns the first 5 todos after the 16th todo', { first: 5, after: 'id_16' }],
            ['returns the first 5 todos after the 20th todo', { first: 5, after: 'id_20' }],
            ['returns the last 5 todos', { last: 5 }],
            ['returns the last 5 todos before the 1st todo', { last: 5, before: 'id_01' }],
            ['returns the last 5 todos before the 5th todo', { last: 5, before: 'id_05' }],
            ['returns the last 5 todos before the 6th todo', { last: 5, before: 'id_06' }],
            ['returns the last 5 todos before the 16th todo', { last: 5, before: 'id_16' }],
        ];
        test.each(VALID_CASES)('%s', (name, connectionArgs) => __awaiter(void 0, void 0, void 0, function* () {
            var _a, _b, _c;
            const result = yield (0, src_1.findManyCursorConnection)((args) => client.todo.findMany(args), () => client.todo.count(), connectionArgs, {
                recordToEdge: (record) => ({
                    node: Object.assign(Object.assign({}, record), { extraNodeField: 'Foo' }),
                    extraEdgeField: 'Bar',
                }),
            });
            expect(result).toMatchSnapshot();
            (_a = result.edges[0]) === null || _a === void 0 ? void 0 : _a.node.extraNodeField;
            (_b = result.edges[0]) === null || _b === void 0 ? void 0 : _b.extraEdgeField;
            (_c = result.nodes[0]) === null || _c === void 0 ? void 0 : _c.extraNodeField;
        }));
    });
    describe('requested fields via resolveInfo', () => {
        beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
            yield client.todo.deleteMany({});
            for (let i = 0; i !== fixtures_1.TODO_FIXTURES.length; i++) {
                yield client.todo.create({ data: fixtures_1.TODO_FIXTURES[i] });
            }
        }));
        it('returns all todos with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.todo.findMany({});
            expect(result).toEqual(fixtures_1.TODO_FIXTURES);
        }));
        it('returns the paginated todos with the base client (sanity check)', () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield client.todo.findMany({ cursor: { id: 'id_05' }, take: 5, skip: 1 });
            expect(result).toMatchSnapshot();
        }));
        const VALID_CASES = [
            ['returns all todos (no fields)', undefined, {}],
            ['returns all todos (edges field)', undefined, { edges: { node: { id: 1 } } }],
            ['returns all todos (nodes field)', undefined, { nodes: { id: 1 } }],
            ['returns all todos (totalCount field)', undefined, { totalCount: 1 }],
            ['returns the first 5 todos (no fields)', { first: 5 }, {}],
            ['returns the first 5 todos (totalCount field)', { first: 5 }, { totalCount: 1 }],
            ['returns the last 5 todos (no fields)', { last: 5 }, {}],
            ['returns the last 5 todos (totalCount field)', { last: 5 }, { totalCount: 1 }],
        ];
        test.each(VALID_CASES)('%s', (name, connectionArgs, mockFields) => __awaiter(void 0, void 0, void 0, function* () {
            mockGraphqlFields.mockReturnValue(mockFields);
            const result = yield (0, src_1.findManyCursorConnection)((args) => client.todo.findMany(args), () => client.todo.count(), connectionArgs, { resolveInfo: { some: 'fake', data: 'here' } });
            expect(result).toMatchSnapshot();
        }));
    });
    describe('invalid arguments', () => {
        const INVALID_CASES = [
            ['errors for invalid arguments (negative first)', { first: -5 }],
            ['errors for invalid arguments (negative last)', { last: -5 }],
            ['errors for invalid arguments (both first & last)', { first: 5, last: 5 }],
            ['errors for invalid arguments (both after & before)', { after: 'id_05', before: 'id_15' }],
            [
                'errors for invalid arguments (both after & before with first)',
                { first: 5, after: 'id_05', before: 'id_15' },
            ],
            ['errors for invalid arguments (after without first)', { after: 'id_05' }],
            ['errors for invalid arguments (before without last)', { before: 'id_15' }],
            ['errors for invalid arguments (after with last)', { last: 5, after: 'id_05' }],
            ['errors for invalid arguments (before with first)', { first: 5, before: 'id_15' }],
            [
                'errors for invalid arguments (kitchensink)',
                { first: 5, after: 'id_05', last: 5, before: 'id_15' },
            ],
        ];
        test.each(INVALID_CASES)('%s', (name, connectionArgs) => __awaiter(void 0, void 0, void 0, function* () {
            let error;
            try {
                yield (0, src_1.findManyCursorConnection)((args) => client.todo.findMany(args), () => client.todo.count(), connectionArgs);
            }
            catch (err) {
                error = err;
            }
            expect(error).not.toEqual(undefined);
            expect(error).toMatchSnapshot();
        }));
    });
});
//# sourceMappingURL=index.spec.js.map